/*! api-smart-diff@0.2.10 */
var ApiSmartDiff=function(r){var n={};function s(e){if(n[e])return n[e].exports;var t=n[e]={i:e,l:!1,exports:{}};return r[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}return s.m=r,s.c=n,s.d=function(e,t,r){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)s.d(r,n,function(e){return t[e]}.bind(null,n));return r},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=0)}([function(_,e,t){"use strict";t.r(e),t.d(e,"messageTraitsRules",function(){return M}),t.d(e,"messageRules",function(){return A}),t.d(e,"asyncApi2Rules",function(){return P}),t.d(e,"openapi3Rules",function(){return E}),t.d(e,"jsonSchemaRules",function(){return w}),t.d(e,"RuleMetaKey",function(){return a}),t.d(e,"DIFF_META_KEY",function(){return n}),t.d(e,"DiffAction",function(){return y}),t.d(e,"ClassifierType",function(){return r}),t.d(e,"breaking",function(){return s}),t.d(e,"nonBreaking",function(){return i}),t.d(e,"unclassified",function(){return o}),t.d(e,"annotation",function(){return f}),t.d(e,"allNonBreaking",function(){return c}),t.d(e,"allBreaking",function(){return u}),t.d(e,"onlyAddBreaking",function(){return l}),t.d(e,"addNonBreaking",function(){return d}),t.d(e,"allUnclassified",function(){return p}),t.d(e,"allAnnotation",function(){return m}),t.d(e,"apiDiff",function(){return L}),t.d(e,"compare",function(){return K}),t.d(e,"apiMerge",function(){return V}),t.d(e,"findExternalRefs",function(){return R});const a=Symbol("rule"),n="$diff";var y,r;(t=y=y||{}).add="add",t.remove="remove",t.replace="replace",(e=r=r||{}).breaking="breaking",e.nonBreaking="non-breaking",e.annotation="annotation",e.unclassified="unclassified";const{breaking:s,nonBreaking:i,unclassified:o,annotation:f}=r,c=[i,i,i],u=[s,s,s],l=[s,i,i],d=[i,s,s],p=[o,o,o],m=[f,f,f],h=e=>e?s:i,g=(e,t)=>h(t),b=e=>Array.isArray(e)?"array":null==typeof e?"null":typeof e,D=e=>{var[,...e]=e.split("/").map(e=>e.replace(new RegExp("~1","g"),"/"));return e},v=(e,t)=>{let r=e;for(var n of[...t]){if(r.hasOwnProperty("/"+n)&&"number"!=typeof n||(n="*"),!r.hasOwnProperty("/"+n))return;{const s=r["/"+n];if(Array.isArray(s))return;r="function"==typeof s?s():s}}return r[a]},R=e=>{if("object"!=typeof e)return[];let t=new Set;if("array"===b(e))for(const n of e)"object"==typeof n&&(t=new Set([...t,...R(n)]));else for(const s of Object.keys(e)){var r;"$ref"===s?([r]=e[s].split("#"),r&&t.add(r)):"object"==typeof e[s]&&(t=new Set([...t,...R(e[s])]))}return[...t]};const O=[s,i,(e,t)=>h(t<e)],x=[s,i,(e,t)=>h(e<t)],S=[g,i,g],j=[g,i,g],T=[s,i,(e,t)=>!(e%t)?i:s],w=(e=p)=>({"/":e,"/title":m,"/multipleOf":T,"/maximum":O,"/exclusiveMaximum":S,"/minimum":x,"/exclusiveMinimum":S,"/maxLength":O,"/minLength":x,"/pattern":[s,i,s],"/maxItems":O,"/minItems":x,"/uniqueItems":j,"/maxProperties":O,"/minProperties":x,"/required":{"/":l,"/*":[s,i,s]},"/enum":{"/":[s,i,s],"/*":[i,s,s]},"/type":[s,i,s],"/not":{"/":[s,i,s],"/*":()=>w(u)},"/allOf":{"/":[s,i,s],"/*":()=>w(u)},"/oneOf":{"/":[s,i,s],"/*":()=>w(d)},"/anyOf":{"/":[s,i,s],"/*":()=>w(d)},"/items":()=>w(d),"/properties":{"/":[s,i,s],"/*":()=>w(d)},"/additionalProperties":()=>w([s,s,g]),"/description":m,"/format":[s,i,s],"/default":[i,s,s],"/nullable":j,"/discriminator":{"/":p,"/propertyName":p,"/mapping":p},"/readOnly":j,"/writeOnly":j,"/example":m,"/examples":m,"/externalDocs":m,"/deprecated":j,"/xml":{"/":p,"/name":p,"/namespace":p,"/prefix":p,"/attribute":p,"/wrapped":p}});var t={"/":d,"/location":d,"/description":m},e={"/summary":m,"/tags":m,"/externalDocs":m,"/bindings":p},k=Object.assign({"/":d,"/*":d,"/operationId":d,"/description":m},e);const M=Object.assign({"/":d,"/*":d,"/headers":p,"/correlationId":t,"/schemaFormat":u,"/contentType":d,"/name":c,"/title":c,"/examples":m},e),A=Object.assign({"/":u,"/headers":p,"/correlationId":t,"/schemaFormat":u,"/contentType":d,"/name":c,"/title":c,"/description":c,"/examples":m,"/traits":M,"/payload":w(u)},e);t=Object.assign({"/":d,"/operationId":d,"/description":m,"/traits":k,"/message":A},e),k={"/":d,"/version":d,"/termsOfService":d,"/license":{"/":d,"/name":u,"/url":l},"/title":m,"/description":m,"/contact":{"/":m,"/name":m,"/url":m,"/email":m}},e={"/":d,"/*":{"/":d,"/url":d,"/description":m,"/protocol":u,"/protocolVersion":u,"/variables":{"/":d,"/*":{"/":d,"/enum":{"/":d,"/*":d},"/default":u,"/description":m,"/examples":m}},"/security":{"/":u,"/*":u},"/bindings":p}},t={"/":d,"/description":c,"/bindings":p,"/subscribe":t,"/publish":t,"/parameters":{"/":u,"/*":{"/":d,"/description":c,"/schema":w(u),"/location":u}}};const P={"/asyncapi":d,"/id":m,"/defaultContentType":u,"/info":k,"/servers":e,"/channels":{"/":d,"/*":t},"/components":c,"/tags":m,"/externalDocs":m};var k={"/":[i,s,s],"/*":{"/":[i,s,s],"/url":[i,s,s],"/description":m,"/variables":{"/":[i,s,s],"/*":{"/":[i,s,s],"/enum":{"/":[i,s,s],"/*":[i,s,s]},"/default":[s,s,s],"/description":m}}}},e={"/":[i,s,s],"/*":{"/":[i,s,s],"/name":[i,s,s],"/in":[i,s,s],"/description":m,"/required":[s,i,g],"/deprecated":[s,i,g]}},t={"/":[i,s,s],"/*":{"/":[i,s,s],"/description":m,"/required":[s,i,g],"/deprecated":[s,i,g]}},I={"/":[i,i,i],"/*":{"/contentType":[i,s,s],"/headers":t,"/style":[i,s,s],"/explode":[i,s,s],"/allowReserved":[i,s,s]}},I={"/":[i,s,s],"/*":{"/":[i,s,s],"/schema":w(u),"/example":m,"/examples":m,"/encoding":I}},F={"/":[i,s,s],"/*":{"/":[i,s,s],"/description":m,"/content":I,"/required":[s,i,(e,t)=>t?s:i]}},I={"/":[i,s,s],"/*":{"/":[i,s,s],"/description":m,"/headers":t,"/content":I}},B={"/":[s,i,o],"/*":[s,i,o]},$={"/":[i,s,s],"/tags":m,"/summary":m,"/description":m,"/externalDocs":m,"/operationId":[i,s,s],"/parameters":e,"/requestBody":F,"/responses":I,"/deprecated":[s,i,g],"/security":B,"/servers":k};const E={"/openapi":[i,s,s],"/info":{"/":[i,s,s],"/title":m,"/description":m,"/termsOfService":m,"/contact":m,"/licence":{"/":[i,s,s],"/name":[s,s,s],"/url":[s,i,i]},"/version":m},"/servers":k,"/paths":{"/":[i,s,s],"/*":((e,t)=>(e[a]={matchKeysFunc:t},e))({"/":[i,s,s],"/summary":m,"/description":m,"/*":$,"/servers":k,"/parameters":e},(e,t)=>!0)},"/components":{"/":[i,i,i],"/schemas":{"/":[i,s,s],"/*":w(d)},"/responses":{"/":[i,s,s],"/*":I},"/parameters":{"/":[i,s,s],"/*":e},"/examples":m,"/requestBodies":{"/":[i,s,s],"/*":F},"/headers":t,"/securitySchemes":{"/":[s,i,s],"/*":{"/":[s,i,s],"/type":[s,i,s],"/description":m,"/name":[s,i,s],"/in":[s,i,s],"/scheme":[s,i,s],"/bearerFormat":m,"/flows":[s,i,s],"/openIdConnectUrl":m}}},"/security":B,"/tags":m,"/externalDocs":m};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */const q=(e,t,r,n)=>{if(e.hasOwnProperty("$ref")){const i=e["$ref"],o=function(e,t){var r={};for(s in e)Object.prototype.hasOwnProperty.call(e,s)&&t.indexOf(s)<0&&(r[s]=e[s]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols)for(var n=0,s=Object.getOwnPropertySymbols(e);n<s.length;n++)t.indexOf(s[n])<0&&Object.prototype.propertyIsEnumerable.call(e,s[n])&&(r[s[n]]=e[s[n]]);return r}(e,["$ref"]);if(r.has(i))return e;var[s,a]=i.split("#");if(s){if(!n.has(s))return e;t=n.get(s)}e=Object.assign(Object.assign({},o),((e,t,r={})=>{let n=e;r=new Map(Object.entries(r));for(const s of D(t)){if(void 0===(n="array"===b(n)?n[+s]:n[s]))break;n=q(n,e,new Set,r)}return n})(t,a,n)),r.add(i),n.set(i,e)}return e},C=(e,t={})=>{const r=e;const n=((e,t)=>{let r=e;for(var n of[...t,""]){if(r.hasOwnProperty("/"+n)&&"number"!=typeof n||(n="*"),!r.hasOwnProperty("/"+n))return p;{const s=r["/"+n];if(Array.isArray(s))return s;r="function"==typeof s?s():s}}return p})(t,e.path)[["add","remove","replace"].indexOf(e.action)];return r.type="function"==typeof n?n(e.before,e.after):n,r};class z{constructor(e,t,r){this.before=e,this.after=t,this.beforeRefs=new Set,this.afterRefs=new Set,this.beforeCache=new Map,this.afterCache=new Map,this.rules="string"==typeof r.rules?this.getBaseRules(r.rules):r.rules,this.trimStrings=r.trimStrings,this.caseSensitive=r.caseSensitive,this.strictArrays=r.strictArrays;var n=r.externalRefs||{};for(const s of Object.keys(n))this.beforeCache.set(s,n[s]),this.afterCache.set(s,n[s])}normalizeString(e){return e=this.trimStrings?e.trim():e,e=this.caseSensitive?e:e.toLowerCase()}dereference(e,t,r){const n="#"+("/"+r.map(e=>String(e).replace(new RegExp("/","g"),"~1")).join("/"));this.beforeRefs.add(n),this.afterRefs.add(n);r=q(e,this.before,this.beforeRefs,this.beforeCache);return[r,q(t,this.after,this.afterRefs,this.afterCache),()=>{e.$ref&&this.beforeRefs.delete(e.$ref),t.$ref&&this.afterRefs.delete(t.$ref),this.beforeRefs.delete(n),this.afterRefs.delete(n)}]}getBaseRules(e){switch(e){case"OpenApi3":return E;case"AsyncApi2":return P;case"JsonSchema":return w()}}equalResult(e,t){return{diffs:[]}}diffResult(e){return{diffs:[C(e,this.rules)]}}mergeResult(e,t){e.diffs=[...e.diffs,...t.diffs]}}const L=(e,t,r)=>{return K(e,t,new z(e,t,r)).diffs},K=(e,t,r,n=[])=>{if(b(e)!==b(t))return r.diffResult({path:n,before:e,after:t,action:y.replace});switch(b(e)){case"object":return N(e,t,r,n);case"array":return U(e,t,r,n);default:return"string"==typeof e&&(e=r.normalizeString(e),t=r.normalizeString(t)),e!==t?r.diffResult({path:n,before:e,after:t,action:y.replace}):r.equalResult(e,n)}},N=(e,t,r,n)=>{var s={diffs:[]};const[a,i,o]=r.dereference(e,t,n);e=Object.keys(a);const f=new Set(Object.keys(i)),c=r.rules&&v(r.rules,n);for(const p of e){var u=[...f].find(e=>e===p||(null===c||void 0===c?void 0:c.matchKeysFunc)&&c.matchKeysFunc(p,e)),l=[...n,p];u?(r.mergeResult(s,K(a[p],i[p],r,l)),f.delete(p)):(u={path:l,before:a[p],action:y.remove},r.mergeResult(s,r.diffResult(u)))}for(const m of f){var d={path:[...n,m],after:i[m],action:y.add};r.mergeResult(s,r.diffResult(d))}return o(),s},U=(t,r,e,n)=>{const s=e.rules&&v(e.rules,n);if(!(e.strictArrays||null!==s&&void 0!==s&&s.matchItemsFunc))return J(t,r,e,n);var a={diffs:[]};const i=new Set(r.keys());for(const c of t.keys()){var o,f=[...n,c];null!==s&&void 0!==s&&s.matchItemsFunc?void 0===(o=(null===s||void 0===s?void 0:s.matchItemsFunc)&&[...i].find(e=>s.matchItemsFunc(t[c],r[e])))?e.mergeResult(a,e.diffResult({path:f,before:t[c],action:y.remove})):(i.delete(o),e.mergeResult(a,K(t[c],r[o],e,f))):c>=r.length?e.mergeResult(a,e.diffResult({path:f,before:t[c],action:y.remove})):(i.delete(c),e.mergeResult(a,K(t[c],r[c],e,f)))}for(const u of i)e.mergeResult(a,e.diffResult({path:[...n,-1],after:r[u],action:y.add}));return a},J=(n,s,a,i)=>{var t,o={diffs:[]};const e=[],f=[],c=new Set,u=new Set;for(let r=0;r<n.length;r++){let t=[];for(let e=0;e<s.length;e++)if(!c.has(e)){var l=K(n[r],s[e],a,[...i,r]);if(!l.diffs.length){c.add(e),u.add(r),t=l;break}t.push(l)}f.push(t)}for(let r=0;r<n.length;r++){const m=f[r];if(u.has(r))e[r]=[],a.mergeResult(o,m);else{const h=[...Array(s.length).keys()];var d,p=h.sort((e,t)=>{return((null==(e=m[e])?void 0:e.length)||0)-((null==(e=m[t])?void 0:e.length)||0)});for(let e=0;e<s.length;e++){let t=p[e];if(!c.has(t)){for(let e=0;e<n.length;e++)if(!u.has(e)&&f[e][t]<f[r][t]){t=-1;break}if(0<=t){a.mergeResult(o,m[t]),u.add(r),c.add(t);break}}}u.has(r)||(d={path:[...i,r],before:n[r],action:y.remove},a.mergeResult(o,a.diffResult(d)))}}for(let e=0;e<s.length;e++)c.has(e)||(t={path:[...i,-1],after:s[e],action:y.add},a.mergeResult(o,a.diffResult(t)));return o},V=(e,t,r)=>{e=K(e,t,new Y(e,t,r)).value;return e};class Y extends z{constructor(e,t,r){super(e,t,r),this._formatMeta=e=>Object.assign({type:e.type,action:e.action},e.action===y.replace?{replaced:e.before}:{}),this.formatMeta=r.formatMeta||(e=>this._formatMeta(e)),this.metaKey=r.metaKey||n,this.arrayMeta=r.arrayMeta||!1}equalResult(e,t){return{diffs:[],value:e,path:t}}diffResult(e){return{diffs:[C(e,this.rules)],diff:C(e,this.rules),path:e.path}}mergeResult(e,t){var r;e.diffs=[...e.diffs,...t.diffs];let n=t.path[t.path.length-1];var s="number"==typeof n;const a=e.value||(s?[]:{});n=-1===n?a.length:n,t.diff?(t.diff.action===y.remove?a[n]=t.diff.before:a[n]=t.diff.after,s=this.formatMeta(t.diff),"array"!==b(a)||this.arrayMeta?a[this.metaKey]=Object.assign(Object.assign({},a[this.metaKey]),{[n]:s}):e.meta={array:Object.assign(Object.assign({},null==(r=e.meta)?void 0:r.array),{[n]:s})}):(a[n]=t.value,t.meta&&(a[this.metaKey]={[n]:t.meta})),e.value=a,e.path=t.path.slice(0,-1)}}}]);